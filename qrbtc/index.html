<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>QR Wizard BTC</title>
  <script src="elliptic.min.js"></script><script src="jsQR.js"></script><script src="qrcode.min.js"></script><script src="crypto-js.min.js"></script>
  <style>
    body { background-color: #121212; color: #E0E0E0; font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; justify-content: center; min-height: 100vh; margin: 0; }
    h1 { margin-bottom: 20px; }
    button { background-color: #333; color: #E0E0E0; border: none; padding: 10px 20px; margin: 5px; cursor: pointer; border-radius: 5px; }
    button:hover { background-color: #555; }
    pre { background-color: #1E1E1E; color: #E0E0E0; padding: 10px; border-radius: 5px; width: 80%; overflow-x: auto; }
  </style>
</head>
<body>
  <h1>EJRCNC: QR Wizard + Minimal BTC Tools</h1>
  <button onclick="cameraQrToTxt()">QRğŸ“·ï¸ --> TXTğŸ“‹ï¸</button>
  <button onclick="clipQrToTxt()">QRğŸ“‹ï¸ --> TXTğŸ“‹ï¸</button>
  <button onclick="clipTxtToQr()">TXTğŸ“‹ï¸ --> QR</button>
  <button onclick="clipTxtToSha256()">TXTğŸ“‹ï¸ --> SHA-256ğŸ“‹ï¸</button>
  <button onclick="clipB64ToTxt()">B64ğŸ“‹ï¸ --> TXTğŸ“‹ï¸</button>
  <button onclick="clipTxtToB64()">TXTğŸ“‹ï¸ --> B64ğŸ“‹ï¸</button>
  <button onclick="hexToWif()">ğŸª™ï¸ PrvKeyHexğŸ“‹ï¸ --> WIFğŸ“‹ï¸ ğŸª™ï¸</button>
  <button onclick="wifToP2PKH()">ğŸª™ï¸ WIFğŸ“‹ï¸ --> P2PKH_AddrğŸ“‹ï¸ ğŸª™ï¸</button>
  <pre id="output"></pre>
  <script>
    //----- FUNCTIONS -------------------------------------------------------------
    async function readClipboardText() { try { return await navigator.clipboard.readText(); } catch (err) { console.error('Failed to read clipboard contents: ', err); return ''; } }
    async function writeClipboardText(text) { try { if (!document.hasFocus()) { console.warn('Document not focused. Waiting for focus.'); await new Promise(resolve => window.addEventListener('focus', resolve, { once: true })); } await navigator.clipboard.writeText(text); console.log('Text written to clipboard:', text); } catch (err) { console.error('Failed to write to clipboard:', err); } }
    async function cameraQrToTxt() { const video = document.createElement('video'), canvasElement = document.createElement('canvas'), canvas = canvasElement.getContext('2d'), output = document.getElementById('output'); navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } }).then((stream) => { video.srcObject = stream; video.setAttribute('playsinline', true); video.play(); requestAnimationFrame(tick); }); function tick() { if (video.readyState === video.HAVE_ENOUGH_DATA) { canvasElement.height = video.videoHeight; canvasElement.width = video.videoWidth; canvas.drawImage(video, 0, 0, canvasElement.width, canvasElement.height); const imageData = canvas.getImageData(0, 0, canvasElement.width, canvasElement.height), code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: 'dontInvert' }); if (code) { output.innerText = code.data; writeClipboardText(code.data); video.srcObject.getTracks().forEach(track => track.stop()); } else requestAnimationFrame(tick); } else requestAnimationFrame(tick); } }
    async function clipQrToTxt() { const output = document.getElementById('output'), imageBlob = await getClipboardImage(); if (imageBlob) { const img = document.createElement('img'); img.src = URL.createObjectURL(imageBlob); img.onload = () => { const canvas = document.createElement('canvas'); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext('2d'); ctx.drawImage(img, 0, 0); const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height), code = jsQR(imageData.data, imageData.width, imageData.height, { inversionAttempts: 'dontInvert' }); if (code) { output.innerText = code.data; writeClipboardText(code.data); } else output.innerText = 'No QR code found'; }; } else output.innerText = 'No image found in clipboard'; }
    async function clipTxtToQr() { const output = document.getElementById('output'), text = await readClipboardText(); if (text) { QRCode.toDataURL(text, { errorCorrectionLevel: 'H' }, async (err, url) => { if (err) { console.error(err); return; } const img = new Image(); img.src = url; output.innerHTML = ''; output.appendChild(img); img.onload = async () => { const canvas = document.createElement('canvas'), context = canvas.getContext('2d'); canvas.width = img.width; canvas.height = img.height; context.drawImage(img, 0, 0); const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png')); await navigator.clipboard.write([new ClipboardItem({ 'image/png': blob })]); console.log('QR code image copied to clipboard'); }; }); } else output.innerText = 'Clipboard is empty'; }
    async function clipTxtToSha256() { const output = document.getElementById('output'), text = await readClipboardText(); if (text) { const encoder = new TextEncoder(), data = encoder.encode(text), hashBuffer = await crypto.subtle.digest('SHA-256', data), hashArray = Array.from(new Uint8Array(hashBuffer)), hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); output.innerText = hashHex; try { await writeClipboardText(hashHex); console.log('SHA-256 hash written to clipboard:', hashHex); } catch (err) { console.error('Failed to write SHA-256 hash to clipboard:', err); } } else output.innerText = 'Clipboard is empty'; }
    async function hexToWif() { const output = document.getElementById('output'), hexKey = await readClipboardText(); if (hexKey.length !== 64) { output.innerText = 'Invalid hex key length. Must be 64 characters.'; return; } const version = '80', compressed = true, extendedKey = version + hexKey + (compressed ? '01' : ''), hash1 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(extendedKey)).toString(), hash2 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hash1)).toString(), checksum = hash2.substr(0, 8), finalKey = extendedKey + checksum, base58 = Base58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'), finalKeyBuffer = CryptoJS.enc.Hex.parse(finalKey), finalKeyUint8Array = new Uint8Array(finalKeyBuffer.words.map(word => [(word >> 24) & 0xff, (word >> 16) & 0xff, (word >> 8) & 0xff, word & 0xff]).flat().slice(0, finalKey.length / 2)), wif = base58.encode(finalKeyUint8Array); output.innerText = wif; try { await writeClipboardText(wif); console.log('WIF written to clipboard:', wif); } catch (err) { console.error('Failed to write WIF to clipboard:', err); } }
    async function wifToP2PKH() { const output = document.getElementById('output'), wif = await readClipboardText(); try { const base58 = Base58('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'), decoded = base58.decode(wif), hex = Array.from(decoded).map(b => b.toString(16).padStart(2, '0')).join(''), privateKeyHex = hex.substring(2, hex.length - 10), isCompressed = hex.slice(hex.length - 2) === '01', actualPrivateKeyHex = isCompressed ? privateKeyHex.slice(0, -2) : privateKeyHex, ec = new elliptic.ec('secp256k1'), privateKey = ec.keyFromPrivate(actualPrivateKeyHex), publicKey = privateKey.getPublic(true, 'hex'), sha256Hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(publicKey)).toString(), ripemd160Hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(sha256Hash)).toString(), versionedHash = '00' + ripemd160Hash, checksum = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(versionedHash)).toString(), checksum2 = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(checksum)).toString(), finalChecksum = checksum2.substr(0, 8), addressHex = versionedHash + finalChecksum, address = base58.encode(new Uint8Array(addressHex.match(/.{1,2}/g).map(byte => parseInt(byte, 16)))); output.innerText = address; await writeClipboardText(address); console.log('P2PKH address written to clipboard:', address); } catch (err) { output.innerText = 'Error: ' + err.message; console.error('Error generating P2PKH address:', err); } }
    async function clipTxtToB64() { const output = document.getElementById('output'), text = await readClipboardText(); if (text) { const base64Text = btoa(text); output.innerText = base64Text; try { await writeClipboardText(base64Text); console.log('Base64 text written to clipboard:', base64Text); } catch (err) { console.error('Failed to write Base64 text to clipboard:', err); } } else output.innerText = 'Clipboard is empty'; }
    async function clipB64ToTxt() { const output = document.getElementById('output'), base64Text = await readClipboardText(); if (base64Text) { try { const text = atob(base64Text); output.innerText = text; try { await writeClipboardText(text); console.log('Decoded text written to clipboard:', text); } catch (err) { console.error('Failed to write decoded text to clipboard:', err); } } catch (e) { output.innerText = 'Invalid Base64 text'; } } else output.innerText = 'Clipboard is empty'; }

    function Base58(ALPHABET) { const ALPHABET_MAP = {}, BASE = ALPHABET.length, LEADER = ALPHABET.charAt(0); for (let z = 0; z < ALPHABET.length; z++) { const x = ALPHABET.charAt(z); if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous'); ALPHABET_MAP[x] = z; } function encode(source) { if (source.length === 0) return ''; let digits = [0]; for (let i = 0; i < source.length; ++i) { let carry = source[i]; for (let j = 0; j < digits.length; ++j) { carry += digits[j] << 8; digits[j] = carry % BASE; carry = (carry / BASE) | 0; } while (carry > 0) { digits.push(carry % BASE); carry = (carry / BASE) | 0; } } let string = ''; for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) string += LEADER; for (let q = digits.length - 1; q >= 0; --q) string += ALPHABET[digits[q]]; return string; } function decode(string) { if (string.length === 0) return new Uint8Array(0); let bytes = [0]; for (let i = 0; i < string.length; i++) { const value = ALPHABET_MAP[string[i]]; if (value === undefined) throw new Error('Non-base58 character'); let carry = value; for (let j = 0; j < bytes.length; ++j) { carry += bytes[j] * BASE; bytes[j] = carry & 0xff; carry >>= 8; } while (carry > 0) { bytes.push(carry & 0xff); carry >>= 8; } } for (let k = 0; string[k] === LEADER && k < string.length - 1; ++k) bytes.push(0); return new Uint8Array(bytes.reverse()); } return { encode, decode }; }
  </script>
</body>
</html>
